---
title: "DDIA 笔记 | 02 数据模型与查询语言"
date: 2022-03-12
draft: true
---

## 前言

近期在研读《Designing Data-Intensive Application》，这本书介绍了分布式系统的方方面面，也包含很多 trade-off 以及实现方式。如果仅是泛泛通读一遍，而不去深究咀嚼，多少会觉得有点可惜。于是就有了这个笔记系列，针对书中的每一个章节，结合自己的理解来写一篇笔记。

多花点时间，也会有更多收获吧。

---

![](http://ddia.vonng.com/img/ch2.png)

## 什么是数据模型

应用存储了数据，而应用又由不同的层级构成，因此数据在这些层级间有不同的表现形式，即数据模型（data model）。自下而上，每一层的数据模型，都是在更低层次的数据模型之上进行封装，再呈现其自身的样貌。

举个例子：

1. API 返回了 VO 对象，VO 对应了现实中的结构和属性
2. API 的处理逻辑里，会用到一些 DTO 来拼接转换
3. DTO 之下，还有真正存储在数据库中的 DO，需要使用通用的数据模型，例如 JSON 文件、关系型数据库里的表、或者图
4. 数据库将这些结构存放在内存、磁盘或者网络的字节中，并且要支持查询、操作
5. 更底层，就是电流、磁场等等

数据模型多种多样，但是万变不离其宗，每一层都掩盖了低层次的复杂度，并在此之上提供更简洁实用的模型，这种抽象的层次使得各层之间可以独立、高效地协作。

数据模型是应用的根基，选用不同的数据模型，也会引导不同的解决问题的思路，所以挑选合适的数据模型是非常重要的，今天我们就来了解一下，更“概念”、更通用的三个数据模型，以及它们各自的查询语言：

1. 关系模型（the relational model）
2. 文档模型（the document model）
3. 图数据模型（graph-based model）

## 关系模型

现在最流行的数据模型 SQL，是基于 Edgar Codd 在 1970 年提出的关系型模型：“数据被组织成**关系** (SQL 中称作**表**)，其中每个关系是**元组**（SQL 中称作**行**）的无序集合”。

早在 60s 和 70s，大型机使用关系模型来处理商业数据，如今的使用场景更普遍、广泛，多用于事务处理和批处理。

在那个年代，其他的数据库都迫使开发者考虑数据库内的数据表现形式，而关系模型就是致力于用更干净的接口来掩盖实现细节。

到了 70s 和 80s 早期，网状模型（network model）和分层模型（hierarchical model）曾是主流的选择，随后就被关系模型所统治。对象数据库（object database）在 80s 晚期和 90s 早期卷土重来，XML 数据库在 2000s 早期出现，但是使用场景很有限。关系模型的挑战者众多，可惜都是昙花一现。随着机器性能变强，互联网的发展越来越快，关系型模型的使用场景也越来越广泛，尤其是在 web 领域。

## 文档模型

到了 2010s，NoSQL 的出现挑战了关系模型的统治地位。不过“NoSQL”这个名称并没有技术含义，原本只是一个讨喜的 twitter 标签，现在可以解读为“Not Only SQL”。

NoSQL 主要是为了解决以下几个问题：

- 比关系型数据库有更好的可伸缩性，包括巨量的数据集和非常高的写入吞吐
- 免费、开源，而不是商业数据库产品
- 关系型数据库不能支持的一些特殊查询
- 打破关系型 schema 的强约束性，增强数据模型的动态性、表现力

不同的应用是为了应对不同的需求，应用的最佳技术栈也可能大不相同。在可预见的未来，关系型数据库将会和众多非关系型数据库并肩作战，这个概念也被称为混合持久化（polyglot persistence）。

### 对象关系不匹配

ORM 是为了解决代码中的数据模型，与关系型数据库里的模型不匹配的问题，例如 ActiveRecord 和 Hibernate，虽然省下了中间翻译层大量的代码，但是仍然不能完美消除两层之间的差异。而且，如果是一对多的关系，需要多次查询才能加载全部数据。

如果使用 JSON 存储数据，是不是能玩美解决这个问题？在第 4 章里也提到了，JSON 作为数据编码格式，也存在一些问题。

### 多对一和多对多关系

文档型数据库面对多对一、多对多关系的窘境，其实在历史上早就发生过。1970 年 IBM 的 IMS 系统，数据模型是分层模型，与使用 JSON 的文档型数据库相似。当时有两种突出的解决方案：1. 关系型模型，后来成为了 SQL；2. 网络模型（也被称为 COSDASYL 模型），一开始有很多人走了这条路，但是最终还是淡出了。

### 回顾网络模型和关系模型

如今，面对多对一、多对多关系，关系型数据库和文档型数据库没什么差异，都是用唯一键做关联，关系型使用**外键**，文档型则使用**文档引用**。这个标识符在通过查询、或者 join 来读取时被解析。迄今为止，文档型数据库并没有走 CODASYL 的老路。

## 如今，对比关系型、文档型

文档型数据库的优势在于 schema 的动态性（架构灵活性），对于一些应用而言，因为更贴近所使用的数据结构，所以有更好的性能；而关系型对 join、一对多、多对多关系有更好的支持。

### 更简单的应用代码

对于哪种模型会带来更简单的应用代码，很难下一个定论，这取决于数据之间的各种关系。对于高度关联的数据而言，文档型表现很糟糕，关系模型可以接受，而图模型是最自然的。

### schema 的灵活性

文档型有时候被叫做“schemaless”，更准确的说法应该是“schema-on-read”，而关系型是“schema-on-write”。

关系型数据库，在数据量很大的时候更新表结构，可能会造成中断。

### 查询的数据局部性

一次查询，加载所有数据，性能好；如果数据分在多个表，可能需要从多个磁盘获取。

但是读写小部分数据时，可能会造成性能浪费；因此推荐，保证文档内容小而全，并且避免写入时增加文档大小。

### 集合文档型和关系型

PostgreSQL 从 9.3 版本，MySQL 从 5.7 版本开始支持 JSON，一些 MongoDB 驱动支持数据引用，看起来文档型和关系型数据库越来越相似，两者的混合在未来也是个很好的方向。

## 数据查询语言

查询语言分为声明式查询语言和命令式查询语言。

SQL 是声明式的，隐藏了实现细节，并且给了数据库引擎优化的空间。

声明式查询语言还可以用在 web 中，例如 css 的选择器。

### MapReduce 查询

MapReduce 是一种编程模型，通过很多机器来大批处理大量的数据。

它既不是声明式查询语言，也不完全是命令式查询 API，而是介于两者之间：查询的逻辑用代码片段来表示，这些代码片段会被处理框架重复性调用。它是基于一些函数式编程语言中的概念：map 和 reduce，是个纯函数，没有副作用。

MapReduce 是低级编程模型，高级查询语言，像是 SQL 可以通过 MapReduce 来实现。而且并没有限制说 SQL 只能运行在一台机子上，MapReduce 在分布式查询执行上也没有垄断地位。

## 图数据模型

如果多对多关系比较多、且复杂，可以考虑使用图数据模型。
一个图由两种对象组成：顶点（vertices）和边（edges）。
图数据模型可以使用在社交、web 网页、轨道交通等网络；除了同质化的数据外，更强大的能力是存储不同类型的数据，Facebook 就用一个图来维护人、地点、事件、推荐信息等。

### 属性图（Property Graphs）

在属性图里，每个顶点包含：
* 一个唯一 id
* 一组出边
* 一组入边
* 一组属性（k-v）

每个边包含：
* 一个唯一 id
* 尾顶点
* 头顶点
* 描述两个顶点关系的标签
* 一组属性（k-v）

可以将图存储看作由两个关系表组成：一个存储顶点，另一个存储边。

### SQL 中的图查询

如果把图数据放入关系型结构中，也可以使用 SQL 来查询，但是有些困难。可以使用 with recursive 语句，但是比 Cypher 更复杂。书中有个例子，使用 Cypher 写了 4 行，而使用 SQL 则要写 29 行，这恰恰说明了不同的数据模型是为不同的应用场景而设计的。**选择适合应用程序的数据模型非常重要**。

### 三元存储和 SPARQL

三元组存储（Triple-Stores），由三部分构成（subject, predicate, object），就像汉语的主谓宾。
和语义网（the semantic web）的区别。

## 总结

历史上，数据最早存储在一个大的树里（the hierarchical model），但是不能很好地表现多对多关系，于是有了关系模型。最近，开发人员发现许多应用不太适合使用关系型数据库，于是有了 NoSQL，包含文档型数据模型和图数据模型。

还有一些未提及的数据模型：基因组的查询模型、PB 级大数据处理、全文检索等。
